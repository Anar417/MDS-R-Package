
#' Metric Multidimensional Scaling (MDS) / Principal Coordinate Analysis (PCoA)
#'
#' This function performs metric multidimensional scaling (MDS), also known as principal coordinate analysis (PCoA), on a given dataset and returns the MDS coordinates along with a 2D MDS plot using the first 2 axis of coordinates. The MDS technique reduces the dimensionality of the data while preserving the pairwise distances between samples as much as possible.
#'
#' @param data A numeric matrix or data frame. The data will be standardized and transposed before the MDS is performed.
#' @param k An integer specifying the number of dimensions for the MDS solution. Defaults to 2, which generates a 2D plot.
#' @param distance_method A string specifying the distance metric to be used for calculating the distance matrix. This can be any method out of "euclidean", "maximum", "manhattan", "canberra", "binary" or "minkowski". Defaults to "euclidean".
#'
#' @return A list "result" with two elements:
#' \item{1}{A numeric matrix of MDS coordinates, where each row corresponds to a sample and each column corresponds to a dimension in the reduced space.}
#' \item{2}{A ggplot2 object representing a 2D MDS plot, where samples are plotted based on their MDS coordinates. The plot also includes the percentage of variation explained by each axis.}
#'
#' @details
#' The function first standardizes and transposes the input data matrix. It then calculates a distance matrix using the specified distance method, converts this distance matrix into a squared distance matrix, and applies double-centering to it. An eigen decomposition is performed on the centered matrix, and the top k eigenvectors and eigenvalues are used to compute the MDS coordinates.
#'
#' The MDS plot generated by using ggplot2 and displays the samples on a 2D plane, with the axes representing the first two MDS dimensions. The axes are labeled with the percentage of variation each dimension captures.
#'
#' @examples
#' example_data <- data.frame(
#' Var1 = c(1.2, 3.5, 4.8, 6.1, 5.7),
#' Var2 = c(2.1, 3.9, 4.4, 5.6, 5.2),
#' Var3 = c(1.9, 3.2, 4.1, 5.8, 5.3)
#' )
#' mds(example_data)
#'
#' mds(matrix(rnorm(100), nrow = 10), distance_method = "manhattan")
#'
#' data(iris)
#' mds_result <- mds(iris[, 1:4])
#' head(mds_result[[1]])
#' print(mds_result[[2]])
#'
#' @import ggplot2
#' @import testthat
#' @export
mds <- function(data, k = 2, distance_method = "euclidean") {
  # Standardize and transpose data matrix
  scaled_data <- scale(t(data), center = TRUE, scale = TRUE)

  # Compute distance matrix using the initially specified distance method
  distance_matrix <- dist(scaled_data, method = distance_method)

  # Convert distance matrix to a squared distance matrix
  distance_matrix_sq <- as.matrix(distance_matrix^2)

  # Get the centering matrix H
  n <- nrow(distance_matrix_sq)
  I <- diag(n)  # Identity matrix of size n
  H <- I - matrix(1, n, n) / n * t(matrix(1, n, n))

  # Apply centering to the squared distance matrix
  B <- -0.5 * H %*% distance_matrix_sq %*% H

  # Perform eigen decomposition on the matrix B and extract eigenvalues and eigenvectors
  eigen_decomp <- eigen(B)
  eigenvalues <- eigen_decomp$values
  eigenvectors <- eigen_decomp$vectors
  k_eigenvalues <- eigenvalues[1:k] # top k eigenvalues
  k_eigenvectors <- eigenvectors[, 1:k] # top k eigenvectors

  # Calculate MDS coordinates
  mds_values <- k_eigenvectors %*% diag(sqrt(k_eigenvalues))

  # Add a naming convention in case of unnamed variables in given data
  rownames(mds_values) <- colnames(data)
  if (is.null(rownames(mds_values))) {
    rownames(mds_values) <- paste("var", 1:ncol(data), sep = "")
  }

  result <- NULL
  result [[1]] <- mds_values

  # Percentage of variation explained by each axis
  mds_variation_per <- round(k_eigenvalues / sum(eigenvalues) * 100, 1)

  # Prepare MDS values for plotting
  mds_data <- data.frame(Sample = rownames(mds_values),
                         X = mds_values[, 1],
                         Y = mds_values[, 2])

  # Create the MDS plot using ggplot2
  result [[2]] <- ggplot(data = mds_data, aes(x = X, y = Y, label = Sample)) +
    geom_label(size = 2) +
    theme_bw() +
    xlab(paste("MDS1 - ", mds_variation_per[1], "%", sep = "")) +
    ylab(paste("MDS2 - ", mds_variation_per[2], "%", sep = "")) +
    ggtitle(paste("MDS plot using", distance_method, "distance"))

  return(result)
}

